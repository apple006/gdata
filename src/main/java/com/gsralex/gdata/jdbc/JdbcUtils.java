package com.gsralex.gdata.jdbc;


import com.gsralex.gdata.exception.DataException;
import com.gsralex.gdata.mapper.FieldColumn;
import com.gsralex.gdata.mapper.FieldValue;
import com.gsralex.gdata.mapper.MapperHelper;
import com.gsralex.gdata.result.*;
import com.gsralex.gdata.sqlhelper.*;
import org.apache.log4j.Logger;

import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * @author gsralex
 * @version 2018/3/10
 */
public class JdbcUtils {

    private static Logger LOGGER = Logger.getLogger(JdbcUtils.class);

    private DataSource dataSource;
    private SqlInsertHelper insertHelper;
    private SqlUpdateHelper updateHelper;
    private MapperHelper mapperHelper;
    private SqlDeleteHelper deleteHelper;


    public JdbcUtils(DataSource dataSource) {
        this.dataSource = dataSource;
        this.insertHelper = new SqlInsertHelper();
        this.updateHelper = new SqlUpdateHelper();
        this.mapperHelper = new MapperHelper();
        this.deleteHelper = new SqlDeleteHelper();
    }

    public <T> boolean insert(T t) {
        return insert(t, false);
    }

    public <T> boolean insert(T t, boolean generatedKey) {
        if (t == null) {
            return false;
        }
        if (generatedKey) {
            if (insertHelper.existsGenerateKey(t.getClass())) {
                return insertGeneratedKey(t);
            } else {
                return insertBean(t);
            }
        } else {
            return insertBean(t);
        }
    }

    private <T> boolean insertBean(T t) {
        if (t == null) {
            return false;
        }
        Object[] objects = insertHelper.getObjects(t);
        String sql = insertHelper.getSql(t.getClass());
        return executeUpdate(sql, objects) != 0 ? true : false;
    }

    private <T> boolean insertGeneratedKey(T t) {
        Class type = t.getClass();
        String sql = insertHelper.getSql(type);
        Object[] objects = insertHelper.getObjects(t);
        JdbcGeneratedKey generatedKey = executeUpdateGenerateKey(sql, objects);
        insertHelper.setIdValue(generatedKey, t);
        return generatedKey.getResult() != 0 ? true : false;
    }

    public <T> int batchInsert(List<T> list) {
        return batchInsert(list, false);
    }

    public <T> int batchInsert(List<T> list, boolean generatedKey) {
        if (list == null || list.size() == 0)
            return 0;
        if (generatedKey) {
            Class type = TypeUtils.getType(list);
            if (insertHelper.existsGenerateKey(type)) {
                return batchInsertGeneratedKey(list);
            } else {
                return batchInsertBean(list);
            }
        } else {
            return batchInsertBean(list);
        }
    }

    private <T> int batchInsertBean(List<T> list) {
        String sql = insertHelper.getSql(TypeUtils.getType(list));
        List<Object[]> objectList = new ArrayList<>();
        for (T t : list) {
            objectList.add(insertHelper.getObjects(t));
        }
        return executeBatch(sql, objectList);
    }

    private <T> int batchInsertGeneratedKey(List<T> list) {
        Class type = TypeUtils.getType(list);
        String sql = insertHelper.getSql(type);
        List<Object[]> objectList = new ArrayList<>();
        for (T t : list) {
            objectList.add(insertHelper.getObjects(t));
        }
        JdbcGeneratedKey generatedKey = executeBatchGeneratedKey(sql, objectList);
        insertHelper.setIdValue(generatedKey, list);
        return generatedKey.getResult();
    }


    public JdbcGeneratedKey executeUpdateGenerateKey(String sql, Object[] objects) {
        PreparedStatement ps = null;
        try {
            ps = pre(sql, objects, true);
            int r = ps.executeUpdate();
            return new JdbcGeneratedKey(r, DataSetUtils.getDataSet(ps.getGeneratedKeys(), true));
        } catch (SQLException e) {
            throw new DataException("executeUpdateGenerateKey", e);
        } finally {
            JdbcHelper.closePsConn(ps);
        }
    }


    public JdbcGeneratedKey executeBatchGeneratedKey(String sql, List<Object[]> objects) {
        return executeBatch(sql, objects, true);
    }


    private JdbcGeneratedKey executeBatch(String sql, List<Object[]> objectsList, boolean autoGeneratedKeys) {
        PreparedStatement ps = null;
        DataSet dataSet = null;
        int result = 0;
        try {
            Connection conn = getConnection();
            conn.setAutoCommit(false);
            if (autoGeneratedKeys) {
                ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            } else {
                ps = conn.prepareStatement(sql);
            }
            for (Object[] objects : objectsList) {
                for (int i = 0, size = objects.length; i < size; i++) {
                    ps.setObject(i + 1, objects[i]);
                }
                ps.addBatch();
            }
            int[] r = ps.executeBatch();
            ps.getConnection().commit();
            result = JdbcHelper.getBatchResult(r);
            if (autoGeneratedKeys) {
                dataSet = DataSetUtils.getDataSet(ps.getGeneratedKeys(), true);
            }
        } catch (SQLException e) {
        } finally {
            JdbcHelper.closePsConn(ps);
        }
        return new JdbcGeneratedKey(result, dataSet);
    }


    public <T> boolean update(T t) {
        if (t == null)
            return false;
        Class type = t.getClass();
        if (!updateHelper.checkValid(type)) {
            return false;
        }
        String sql = updateHelper.getSql(type);
        Object[] objects = updateHelper.getObjects(t);
        return executeUpdate(sql, objects) != 0 ? true : false;
    }

    public <T> int batchUpdate(List<T> list) {
        if (list == null || list.size() == 0) {
            return 0;
        }
        Class<T> type = (Class<T>) list.get(0).getClass();
        if (!updateHelper.checkValid(type)) {
            return 0;
        }
        String sql = updateHelper.getSql(type);
        List<Object[]> objectList = new ArrayList<>();
        for (T t : list) {
            objectList.add(updateHelper.getObjects(t));
        }
        return executeBatch(sql, objectList);
    }

    public int executeBatch(String sql, List<Object[]> objects) {
        return executeBatch(sql, objects, false).getResult();
    }


    public int executeUpdate(String sql, Object[] objects) {
        PreparedStatement ps = null;
        try {
            ps = pre(sql, objects);
            return ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error("JdbcHelper.executeUpdate", e);
            return 0;
        } finally {
            JdbcHelper.closePsConn(ps);
        }
    }

    public <T> T get(String sql, Object[] objects, Class<T> type) {
        List<T> list = getList(sql, objects, type);
        if (list != null && list.size() != 0) {
            return list.get(0);
        }
        return null;
    }

    public <T> List<T> getList(String sql, Object[] objects, Class<T> type) {
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = pre(sql, objects);
            rs = ps.executeQuery();
            return mapperList(rs, type);
        } catch (SQLException e) {
            LOGGER.error("JdbcHelper.getList", e);
            return null;
        } finally {
            JdbcHelper.closeRs(rs);
            JdbcHelper.closePsConn(ps);
        }
    }

    public DataSet queryForDataSet(String sql, Object... objects) {
        PreparedStatement ps = null;
        ResultSet rs = null;
        try {
            ps = pre(sql, objects);
            rs = ps.executeQuery();
            return DataSetUtils.getDataSet(rs, false);
        } catch (SQLException e) {
            throw new DataException("queryForDataSet", e);
        } finally {
            JdbcHelper.closeRs(rs);
            JdbcHelper.closePs(ps);
        }
    }


    public List<Map<String, Object>> queryForList(String sql, Object... objects) {
        DataSet dataSet = queryForDataSet(sql, objects);
        List<Map<String, Object>> mapList = new ArrayList<>();
        for (DataRow dataRow : dataSet.getRows()) {
            mapList.add(dataRow.getMap());
        }
        return mapList;
    }

    public <T> boolean delete(T t) {
        if (t == null) {
            return false;
        }
        Class type = t.getClass();
        if (!deleteHelper.checkValid(type)) {
            return false;
        }
        String sql = deleteHelper.getSql(type);
        Object[] objects = deleteHelper.getObjects(t);
        return executeUpdate(sql, objects) != 0 ? true : false;
    }

    public <T> int batchDelete(List<T> list) {
        if (list == null || list.size() == 0) {
            return 0;
        }
        Class type = TypeUtils.getType(list);
        if (!deleteHelper.checkValid(type)) {
            return 0;
        }
        String sql = deleteHelper.getSql(type);
        List<Object[]> argList = new ArrayList<>();
        for (T t : list) {
            Object[] objects = deleteHelper.getObjects(t);
            argList.add(objects);
        }
        return executeBatch(sql, argList);
    }


    private <T> List<T> mapperList(ResultSet rs, Class<T> type) {
        List<T> list = new ArrayList<>();
        try {
            while (rs.next()) {
                list.add(mapperHelper.mapperEntity(rs, type));
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return list;
    }


    private PreparedStatement pre(String sql, Object[] objects) {
        return pre(sql, objects, false);
    }

    private PreparedStatement pre(String sql, Object[] objects, boolean autoGeneratedKeys) {
        try {
            Connection conn = getConnection();
            PreparedStatement ps;
            if (autoGeneratedKeys) {
                ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            } else {
                ps = conn.prepareStatement(sql);
            }
            if (objects != null && objects.length != 0) {
                for (int i = 0; i < objects.length; i++) {
                    ps.setObject(i + 1, objects[i]);
                }
            }
            return ps;
        } catch (SQLException e) {
            LOGGER.error("JdbcHelper.pre", e);
            return null;
        }
    }

    private Connection getConnection() {
        try {
            return this.dataSource.getConnection();
        } catch (SQLException e) {
            LOGGER.error("JdbcHelper.getConnection", e);
            return null;
        }
    }
}
